name: ci
on:
  push:
    branches: [ develop, main ]
  pull_request:

jobs:
  lint_unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: '**/go.sum'
      - name: Docker info
        run: docker info
      - run: go vet ./...
      - run: go test ./... -count=1
      - name: Integration tests (Postgres via testcontainers)
        env:
          RUN_PG_INTEGRATION: "1"
        run: |
          go test -tags=integration ./internal/store -count=1
          go test -tags=integration ./internal/manager -count=1

  build_push_amd64:
    runs-on: ubuntu-latest
    needs: [lint_unit, gosec_scan, trivy_fs, trivy_config, trivy_images]
    strategy:
      matrix:
        arch: [amd64]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build images (amd64)
        run: |
          TAG=${GITHUB_REF##*/}
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then EXTRA_TAGS="--tag ghcr.io/vaheed/kubenova/manager:$TAG --tag ghcr.io/vaheed/kubenova/agent:$TAG"; fi
          docker buildx build --platform linux/${{ matrix.arch }} -t ghcr.io/vaheed/kubenova/manager:dev $EXTRA_TAGS --push -f build/Dockerfile.manager .
          docker buildx build --platform linux/${{ matrix.arch }} -t ghcr.io/vaheed/kubenova/agent:dev $EXTRA_TAGS --push -f build/Dockerfile.agent .

  build_push_arm64:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    needs: [lint_unit, gosec_scan, trivy_fs, trivy_config, trivy_images]
    strategy:
      matrix:
        arch: [arm64]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build images (arm64)
        run: |
          TAG=${GITHUB_REF##*/}
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then EXTRA_TAGS="--tag ghcr.io/vaheed/kubenova/manager:$TAG --tag ghcr.io/vaheed/kubenova/agent:$TAG"; fi
          docker buildx build --platform linux/${{ matrix.arch }} -t ghcr.io/vaheed/kubenova/manager:dev $EXTRA_TAGS --push -f build/Dockerfile.manager .
          docker buildx build --platform linux/${{ matrix.arch }} -t ghcr.io/vaheed/kubenova/agent:dev $EXTRA_TAGS --push -f build/Dockerfile.agent .

  e2e_validation:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image (local) and load into kind
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres via docker compose
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          set -euo pipefail
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run validation suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/validation.sh | tee artifacts/validation.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-validation
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_functional:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run functional suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/functional.sh | tee artifacts/functional.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-functional
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_load:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run load suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/load.sh | tee artifacts/load.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-load
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_runtime:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run runtime suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/runtime.sh | tee artifacts/runtime.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-runtime
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_pentest:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run pentest suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/pentest.sh | tee artifacts/pentest.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-pentest
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_end_to_end:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run e2e suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/end_to_end.sh | tee artifacts/e2e.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-end-to-end
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_user_functions:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: |
          docker compose -f docker-compose.dev.yml up -d --build
          curl -fsS http://localhost:8080/wait?timeout=120
      - name: Run user functions suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/user_functions.sh | tee artifacts/user-functions.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-user-functions
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_conditions:
    runs-on: ubuntu-latest
    needs: build_push_amd64
    steps:
      - uses: actions/checkout@v4
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - uses: helm/kind-action@v1
        with:
          cluster_name: kubenova-e2e
      - name: Build Agent image and load
        run: |
          docker build -t ghcr.io/vaheed/kubenova/agent:dev -f build/Dockerfile.agent .
          kind load docker-image ghcr.io/vaheed/kubenova/agent:dev --name kubenova-e2e
      - name: Start Manager + Postgres
        env:
          KUBENOVA_REQUIRE_AUTH: "false"
          MANAGER_URL_PUBLIC: http://localhost:8080
          AGENT_IMAGE: ghcr.io/vaheed/kubenova/agent:dev
        run: docker compose -f docker-compose.dev.yml up -d --build
      - name: Run conditions suite
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/conditions.sh | tee artifacts/conditions.log
      - name: Collect artifacts
        if: always()
        run: |
          bash -lc 'source e2e/common.sh; collect_artifacts' || true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-conditions
          path: artifacts
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.dev.yml down -v || true

  e2e_integration:
    runs-on: ubuntu-latest
    needs: lint_unit
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with: { go-version: '1.24' }
      - name: Run integration suite (testcontainers)
        env:
          RUN_PG_INTEGRATION: "1"
        run: |
          set -o pipefail
          mkdir -p artifacts
          bash e2e/suites/integration.sh | tee artifacts/integration.log
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-integration
          path: artifacts

  docs_publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: |
          cd docs/site
          npm ci || npm install
          npm run docs:build
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        if: github.ref == 'refs/heads/main'
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: docs/site/.vitepress/dist

  gosec_scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: '**/go.sum'
      - name: Install gosec
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@latest
      - name: Run gosec
        run: |
          $(go env GOPATH)/bin/gosec ./...

  build_images_scan:
    runs-on: ubuntu-latest
    needs: lint_unit
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - name: Build scan images
        run: |
          docker buildx build -t manager:scan -f build/Dockerfile.manager --load .
          docker buildx build -t kubenova-agent:scan -f build/Dockerfile.agent --load .
          docker save manager:scan -o api-image.tar
          docker save kubenova-agent:scan -o agent-image.tar
      - uses: actions/upload-artifact@v4
        with:
          name: scan-images
          path: |
            api-image.tar
            agent-image.tar

  trivy_fs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Clean Trivy cache dir (avoid tar restore conflicts)
        run: rm -rf ~/.cache/trivy || true
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: ${{ runner.os }}-trivy-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-trivy-
      - name: Trivy FS scan
        uses: aquasecurity/trivy-action@0.20.0
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          format: 'table'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'

  trivy_config:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Clean Trivy cache dir (avoid tar restore conflicts)
        run: rm -rf ~/.cache/trivy || true
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: ${{ runner.os }}-trivy-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-trivy-
      - name: Trivy Config scan (Helm, manifests)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          scan-type: 'config'
          scan-ref: 'deploy'
          severity: 'HIGH,CRITICAL'
          format: 'table'
          exit-code: '1'

  trivy_images:
    runs-on: ubuntu-latest
    needs: build_images_scan
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Clean Trivy cache dir (avoid tar restore conflicts)
        run: rm -rf ~/.cache/trivy || true
      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: ${{ runner.os }}-trivy-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-trivy-
      - uses: actions/download-artifact@v4
        with:
          name: scan-images
      - name: Load images
        run: |
          docker load -i api-image.tar
          docker load -i agent-image.tar
      - name: Trivy image scan (Manager)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: 'manager:scan'
          format: 'table'
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: '1'
      - name: Trivy image scan (Agent)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: 'kubenova-agent:scan'
          format: 'table'
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: '1'
      - name: Gitleaks secrets scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  charts_publish:
    runs-on: ubuntu-latest
    needs:
      - build_push_amd64
      - e2e_validation
      - e2e_functional
      - e2e_load
      - e2e_runtime
      - e2e_pentest
      - e2e_end_to_end
      - e2e_user_functions
      - e2e_conditions
      - e2e_integration
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4
      - name: Package charts
        env:
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          CHANNEL=stable
          DEST=charts/stable
          if [[ "$BRANCH" == "develop" ]]; then CHANNEL=dev; DEST=charts/dev; fi
          mkdir -p out
          package_chart() {
            CHART_DIR=$1
            NAME=$(basename "$CHART_DIR")
            TMP=$(mktemp -d)
            rsync -a "$CHART_DIR/" "$TMP/"
            if [[ "$CHANNEL" == "dev" ]]; then
              # append -dev to version in Chart.yaml
              sed -E -i 's/^(version: .*)$/\1-dev/' "$TMP/Chart.yaml"
            fi
            helm package "$TMP" -d out
          }
          package_chart deploy/helm/manager
          package_chart deploy/helm/kubenova-agent
          ls -la out
          # create latest copies (for direct downloads convenience)
          for f in out/*.tgz; do cp "$f" "out/$(basename "$f" | sed 's/-[0-9].*/-latest.tgz/')"; done
      - name: Build Helm repo index (merge existing)
        env:
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          CHANNEL=stable
          DEST=charts/stable
          if [[ "$BRANCH" == "develop" ]]; then CHANNEL=dev; DEST=charts/dev; fi
          mkdir -p repo
          mv out/*.tgz repo/
          # try merge with existing index from Pages if present
          EXISTING_URL="https://vaheed.github.io/kubenova/${DEST}/index.yaml"
          curl -fsS "$EXISTING_URL" -o existing.yaml || true
          if [[ -s existing.yaml ]]; then
            helm repo index repo --merge existing.yaml
          else
            helm repo index repo
          fi
          ls -la repo
      - name: Publish charts to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: repo
          destination_dir: ${{ github.ref_name == 'develop' && 'charts/dev' || 'charts/stable' }}
          keep_files: true

  charts_push_oci:
    runs-on: ubuntu-latest
    needs:
      - build_push_amd64
      - e2e_validation
      - e2e_functional
      - e2e_load
      - e2e_runtime
      - e2e_pentest
      - e2e_end_to_end
      - e2e_user_functions
      - e2e_conditions
      - e2e_integration
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4
      - name: Login to GHCR for Helm/ORAS
        run: echo ${{ secrets.GITHUB_TOKEN }} | helm registry login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Package charts (OCI)
        env:
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          mkdir -p out
          package_chart() {
            CHART_DIR=$1
            NAME=$(basename "$CHART_DIR")
            TMP=$(mktemp -d)
            rsync -a "$CHART_DIR/" "$TMP/"
            if [[ "$BRANCH" == "develop" ]]; then
              sed -E -i 's/^(version: .*)$/\1-dev/' "$TMP/Chart.yaml"
            fi
            helm package "$TMP" -d out
          }
          package_chart deploy/helm/manager
          package_chart deploy/helm/kubenova-agent
          ls -la out
      - name: Push charts to GHCR (OCI)
        env:
          OWNER: ${{ github.repository_owner }}
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          REPO="oci://ghcr.io/${OWNER}/kubenova"
          for f in out/*.tgz; do echo pushing "$f"; helm push "$f" "$REPO"; done
      - name: Tag charts as latest via ORAS
        if: always()
        uses: oras-project/setup-oras@v1
      - name: Apply lightweight tags (latest or dev)
        env:
          OWNER: ${{ github.repository_owner }}
          BRANCH: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          echo ${{ secrets.GITHUB_TOKEN }} | oras login ghcr.io -u ${{ github.actor }} --password-stdin
          for f in out/*.tgz; do
            name=$(helm show chart "$f" | awk -F': ' '/^name:/{print $2; exit}')
            ver=$(helm show chart "$f" | awk -F': ' '/^version:/{print $2; exit}')
            src="ghcr.io/${OWNER}/kubenova/${name}:${ver}"
            if [[ "$BRANCH" == "develop" ]]; then dst="ghcr.io/${OWNER}/kubenova/${name}:dev"; else dst="ghcr.io/${OWNER}/kubenova/${name}:latest"; fi
            echo "Tagging $src -> $dst"
            oras copy "$src" "$dst"
          done
